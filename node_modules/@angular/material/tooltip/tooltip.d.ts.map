{"version":3,"file":"tooltip.d.ts","sources":["tooltip.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { AnimationEvent } from '@angular/animations';\r\nimport { AriaDescriber, FocusMonitor } from '@angular/cdk/a11y';\r\nimport { Directionality } from '@angular/cdk/bidi';\r\nimport { BooleanInput, NumberInput } from '@angular/cdk/coercion';\r\nimport { BreakpointObserver, BreakpointState } from '@angular/cdk/layout';\r\nimport { ConnectedPosition, OriginConnectionPosition, Overlay, OverlayConnectionPosition, OverlayRef, ScrollStrategy } from '@angular/cdk/overlay';\r\nimport { Platform } from '@angular/cdk/platform';\r\nimport { ComponentType } from '@angular/cdk/portal';\r\nimport { ScrollDispatcher } from '@angular/cdk/scrolling';\r\nimport { ChangeDetectorRef, ElementRef, InjectionToken, NgZone, OnDestroy, ViewContainerRef, AfterViewInit } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\n/** Possible positions for a tooltip. */\r\nexport declare type TooltipPosition = 'left' | 'right' | 'above' | 'below' | 'before' | 'after';\r\n/**\r\n * Options for how the tooltip trigger should handle touch gestures.\r\n * See `MatTooltip.touchGestures` for more information.\r\n */\r\nexport declare type TooltipTouchGestures = 'auto' | 'on' | 'off';\r\n/** Possible visibility states of a tooltip. */\r\nexport declare type TooltipVisibility = 'initial' | 'visible' | 'hidden';\r\n/** Time in ms to throttle repositioning after scroll events. */\r\nexport declare const SCROLL_THROTTLE_MS = 20;\r\n/**\r\n * CSS class that will be attached to the overlay panel.\r\n * @deprecated\r\n * @breaking-change 13.0.0 remove this variable\r\n */\r\nexport declare const TOOLTIP_PANEL_CLASS = \"mat-tooltip-panel\";\r\n/**\r\n * Creates an error to be thrown if the user supplied an invalid tooltip position.\r\n * @docs-private\r\n */\r\nexport declare function getMatTooltipInvalidPositionError(position: string): Error;\r\n/** Injection token that determines the scroll handling while a tooltip is visible. */\r\nexport declare const MAT_TOOLTIP_SCROLL_STRATEGY: InjectionToken<() => ScrollStrategy>;\r\n/** @docs-private */\r\nexport declare function MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY(overlay: Overlay): () => ScrollStrategy;\r\n/** @docs-private */\r\nexport declare const MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER: {\r\n    provide: InjectionToken<() => ScrollStrategy>;\r\n    deps: (typeof Overlay)[];\r\n    useFactory: typeof MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY;\r\n};\r\n/** Default `matTooltip` options that can be overridden. */\r\nexport interface MatTooltipDefaultOptions {\r\n    showDelay: number;\r\n    hideDelay: number;\r\n    touchendHideDelay: number;\r\n    touchGestures?: TooltipTouchGestures;\r\n    position?: TooltipPosition;\r\n}\r\n/** Injection token to be used to override the default options for `matTooltip`. */\r\nexport declare const MAT_TOOLTIP_DEFAULT_OPTIONS: InjectionToken<MatTooltipDefaultOptions>;\r\n/** @docs-private */\r\nexport declare function MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY(): MatTooltipDefaultOptions;\r\nexport declare abstract class _MatTooltipBase<T extends _TooltipComponentBase> implements OnDestroy, AfterViewInit {\r\n    private _overlay;\r\n    private _elementRef;\r\n    private _scrollDispatcher;\r\n    private _viewContainerRef;\r\n    private _ngZone;\r\n    private _platform;\r\n    private _ariaDescriber;\r\n    private _focusMonitor;\r\n    protected _dir: Directionality;\r\n    private _defaultOptions;\r\n    _overlayRef: OverlayRef | null;\r\n    _tooltipInstance: T | null;\r\n    private _portal;\r\n    private _position;\r\n    private _disabled;\r\n    private _tooltipClass;\r\n    private _scrollStrategy;\r\n    private _viewInitialized;\r\n    private _pointerExitEventsInitialized;\r\n    protected abstract readonly _tooltipComponent: ComponentType<T>;\r\n    protected _viewportMargin: number;\r\n    private _currentPosition;\r\n    protected readonly _cssClassPrefix: string;\r\n    /** Allows the user to define the position of the tooltip relative to the parent element */\r\n    get position(): TooltipPosition;\r\n    set position(value: TooltipPosition);\r\n    /** Disables the display of the tooltip. */\r\n    get disabled(): boolean;\r\n    set disabled(value: boolean);\r\n    /** The default delay in ms before showing the tooltip after show is called */\r\n    showDelay: number;\r\n    /** The default delay in ms before hiding the tooltip after hide is called */\r\n    hideDelay: number;\r\n    /**\r\n     * How touch gestures should be handled by the tooltip. On touch devices the tooltip directive\r\n     * uses a long press gesture to show and hide, however it can conflict with the native browser\r\n     * gestures. To work around the conflict, Angular Material disables native gestures on the\r\n     * trigger, but that might not be desirable on particular elements (e.g. inputs and draggable\r\n     * elements). The different values for this option configure the touch event handling as follows:\r\n     * - `auto` - Enables touch gestures for all elements, but tries to avoid conflicts with native\r\n     *   browser gestures on particular elements. In particular, it allows text selection on inputs\r\n     *   and textareas, and preserves the native browser dragging on elements marked as `draggable`.\r\n     * - `on` - Enables touch gestures for all elements and disables native\r\n     *   browser gestures with no exceptions.\r\n     * - `off` - Disables touch gestures. Note that this will prevent the tooltip from\r\n     *   showing on touch devices.\r\n     */\r\n    touchGestures: TooltipTouchGestures;\r\n    /** The message to be displayed in the tooltip */\r\n    get message(): string;\r\n    set message(value: string);\r\n    private _message;\r\n    /** Classes to be passed to the tooltip. Supports the same syntax as `ngClass`. */\r\n    get tooltipClass(): string | string[] | Set<string> | {\r\n        [key: string]: any;\r\n    };\r\n    set tooltipClass(value: string | string[] | Set<string> | {\r\n        [key: string]: any;\r\n    });\r\n    /** Manually-bound passive event listeners. */\r\n    private readonly _passiveListeners;\r\n    /** Reference to the current document. */\r\n    private _document;\r\n    /** Timer started at the last `touchstart` event. */\r\n    private _touchstartTimeout;\r\n    /** Emits when the component is destroyed. */\r\n    private readonly _destroyed;\r\n    constructor(_overlay: Overlay, _elementRef: ElementRef<HTMLElement>, _scrollDispatcher: ScrollDispatcher, _viewContainerRef: ViewContainerRef, _ngZone: NgZone, _platform: Platform, _ariaDescriber: AriaDescriber, _focusMonitor: FocusMonitor, scrollStrategy: any, _dir: Directionality, _defaultOptions: MatTooltipDefaultOptions, _document: any);\r\n    ngAfterViewInit(): void;\r\n    /**\r\n     * Dispose the tooltip when destroyed.\r\n     */\r\n    ngOnDestroy(): void;\r\n    /** Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input */\r\n    show(delay?: number): void;\r\n    /** Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input */\r\n    hide(delay?: number): void;\r\n    /** Shows/hides the tooltip */\r\n    toggle(): void;\r\n    /** Returns true if the tooltip is currently visible to the user */\r\n    _isTooltipVisible(): boolean;\r\n    /**\r\n     * Handles the keydown events on the host element.\r\n     * Needs to be an arrow function so that we can use it in addEventListener.\r\n     */\r\n    private _handleKeydown;\r\n    /** Create the overlay config and position strategy */\r\n    private _createOverlay;\r\n    /** Detaches the currently-attached tooltip. */\r\n    private _detach;\r\n    /** Updates the position of the current tooltip. */\r\n    private _updatePosition;\r\n    /** Adds the configured offset to a position. Used as a hook for child classes. */\r\n    protected _addOffset(position: ConnectedPosition): ConnectedPosition;\r\n    /**\r\n     * Returns the origin position and a fallback position based on the user's position preference.\r\n     * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).\r\n     */\r\n    _getOrigin(): {\r\n        main: OriginConnectionPosition;\r\n        fallback: OriginConnectionPosition;\r\n    };\r\n    /** Returns the overlay position and a fallback position based on the user's preference */\r\n    _getOverlayPosition(): {\r\n        main: OverlayConnectionPosition;\r\n        fallback: OverlayConnectionPosition;\r\n    };\r\n    /** Updates the tooltip message and repositions the overlay according to the new message length */\r\n    private _updateTooltipMessage;\r\n    /** Updates the tooltip class */\r\n    private _setTooltipClass;\r\n    /** Inverts an overlay position. */\r\n    private _invertPosition;\r\n    /** Updates the class on the overlay panel based on the current position of the tooltip. */\r\n    private _updateCurrentPositionClass;\r\n    /** Binds the pointer events to the tooltip trigger. */\r\n    private _setupPointerEnterEventsIfNeeded;\r\n    private _setupPointerExitEventsIfNeeded;\r\n    private _addListeners;\r\n    private _platformSupportsMouseEvents;\r\n    /** Listener for the `wheel` event on the element. */\r\n    private _wheelListener;\r\n    /** Disables the native browser gestures, based on how the tooltip has been configured. */\r\n    private _disableNativeGesturesIfNecessary;\r\n    static ngAcceptInputType_disabled: BooleanInput;\r\n    static ngAcceptInputType_hideDelay: NumberInput;\r\n    static ngAcceptInputType_showDelay: NumberInput;\r\n}\r\n/**\r\n * Directive that attaches a material design tooltip to the host element. Animates the showing and\r\n * hiding of a tooltip provided position (defaults to below the element).\r\n *\r\n * https://material.io/design/components/tooltips.html\r\n */\r\nexport declare class MatTooltip extends _MatTooltipBase<TooltipComponent> {\r\n    protected readonly _tooltipComponent: typeof TooltipComponent;\r\n    constructor(overlay: Overlay, elementRef: ElementRef<HTMLElement>, scrollDispatcher: ScrollDispatcher, viewContainerRef: ViewContainerRef, ngZone: NgZone, platform: Platform, ariaDescriber: AriaDescriber, focusMonitor: FocusMonitor, scrollStrategy: any, dir: Directionality, defaultOptions: MatTooltipDefaultOptions, _document: any);\r\n}\r\nexport declare abstract class _TooltipComponentBase implements OnDestroy {\r\n    private _changeDetectorRef;\r\n    /** Message to display in the tooltip */\r\n    message: string;\r\n    /** Classes to be added to the tooltip. Supports the same syntax as `ngClass`. */\r\n    tooltipClass: string | string[] | Set<string> | {\r\n        [key: string]: any;\r\n    };\r\n    /** The timeout ID of any current timer set to show the tooltip */\r\n    _showTimeoutId: number | undefined;\r\n    /** The timeout ID of any current timer set to hide the tooltip */\r\n    _hideTimeoutId: number | undefined;\r\n    /** Property watched by the animation framework to show or hide the tooltip */\r\n    _visibility: TooltipVisibility;\r\n    /** Whether interactions on the page should close the tooltip */\r\n    private _closeOnInteraction;\r\n    /** Subject for notifying that the tooltip has been hidden from the view */\r\n    private readonly _onHide;\r\n    constructor(_changeDetectorRef: ChangeDetectorRef);\r\n    /**\r\n     * Shows the tooltip with an animation originating from the provided origin\r\n     * @param delay Amount of milliseconds to the delay showing the tooltip.\r\n     */\r\n    show(delay: number): void;\r\n    /**\r\n     * Begins the animation to hide the tooltip after the provided delay in ms.\r\n     * @param delay Amount of milliseconds to delay showing the tooltip.\r\n     */\r\n    hide(delay: number): void;\r\n    /** Returns an observable that notifies when the tooltip has been hidden from view. */\r\n    afterHidden(): Observable<void>;\r\n    /** Whether the tooltip is being displayed. */\r\n    isVisible(): boolean;\r\n    ngOnDestroy(): void;\r\n    _animationStart(): void;\r\n    _animationDone(event: AnimationEvent): void;\r\n    /**\r\n     * Interactions on the HTML body should close the tooltip immediately as defined in the\r\n     * material design spec.\r\n     * https://material.io/design/components/tooltips.html#behavior\r\n     */\r\n    _handleBodyInteraction(): void;\r\n    /**\r\n     * Marks that the tooltip needs to be checked in the next change detection run.\r\n     * Mainly used for rendering the initial text before positioning a tooltip, which\r\n     * can be problematic in components with OnPush change detection.\r\n     */\r\n    _markForCheck(): void;\r\n    /**\r\n     * Callback for when the timeout in this.show() gets completed.\r\n     * This method is only needed by the mdc-tooltip, and so it is only implemented\r\n     * in the mdc-tooltip, not here.\r\n     */\r\n    protected _onShow(): void;\r\n}\r\n/**\r\n * Internal component that wraps the tooltip's content.\r\n * @docs-private\r\n */\r\nexport declare class TooltipComponent extends _TooltipComponentBase {\r\n    private _breakpointObserver;\r\n    /** Stream that emits whether the user has a handset-sized display.  */\r\n    _isHandset: Observable<BreakpointState>;\r\n    constructor(changeDetectorRef: ChangeDetectorRef, _breakpointObserver: BreakpointObserver);\r\n}\r\n"]}