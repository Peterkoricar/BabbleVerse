{"version":3,"file":"focus-monitor.d.ts","sources":["focus-monitor.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Platform } from '@angular/cdk/platform';\r\nimport { ElementRef, EventEmitter, InjectionToken, NgZone, OnDestroy, AfterViewInit } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { InputModalityDetector } from '../input-modality/input-modality-detector';\r\nexport declare type FocusOrigin = 'touch' | 'mouse' | 'keyboard' | 'program' | null;\r\n/**\r\n * Corresponds to the options that can be passed to the native `focus` event.\r\n * via https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus\r\n */\r\nexport interface FocusOptions {\r\n    /** Whether the browser should scroll to the element when it is focused. */\r\n    preventScroll?: boolean;\r\n}\r\n/** Detection mode used for attributing the origin of a focus event. */\r\nexport declare const enum FocusMonitorDetectionMode {\r\n    /**\r\n     * Any mousedown, keydown, or touchstart event that happened in the previous\r\n     * tick or the current tick will be used to assign a focus event's origin (to\r\n     * either mouse, keyboard, or touch). This is the default option.\r\n     */\r\n    IMMEDIATE = 0,\r\n    /**\r\n     * A focus event's origin is always attributed to the last corresponding\r\n     * mousedown, keydown, or touchstart event, no matter how long ago it occurred.\r\n     */\r\n    EVENTUAL = 1\r\n}\r\n/** Injectable service-level options for FocusMonitor. */\r\nexport interface FocusMonitorOptions {\r\n    detectionMode?: FocusMonitorDetectionMode;\r\n}\r\n/** InjectionToken for FocusMonitorOptions. */\r\nexport declare const FOCUS_MONITOR_DEFAULT_OPTIONS: InjectionToken<FocusMonitorOptions>;\r\n/** Monitors mouse and keyboard events to determine the cause of focus events. */\r\nexport declare class FocusMonitor implements OnDestroy {\r\n    private _ngZone;\r\n    private _platform;\r\n    private readonly _inputModalityDetector;\r\n    /** The focus origin that the next focus event is a result of. */\r\n    private _origin;\r\n    /** The FocusOrigin of the last focus event tracked by the FocusMonitor. */\r\n    private _lastFocusOrigin;\r\n    /** Whether the window has just been focused. */\r\n    private _windowFocused;\r\n    /** The timeout id of the window focus timeout. */\r\n    private _windowFocusTimeoutId;\r\n    /** The timeout id of the origin clearing timeout. */\r\n    private _originTimeoutId;\r\n    /**\r\n     * Whether the origin was determined via a touch interaction. Necessary as properly attributing\r\n     * focus events to touch interactions requires special logic.\r\n     */\r\n    private _originFromTouchInteraction;\r\n    /** Map of elements being monitored to their info. */\r\n    private _elementInfo;\r\n    /** The number of elements currently being monitored. */\r\n    private _monitoredElementCount;\r\n    /**\r\n     * Keeps track of the root nodes to which we've currently bound a focus/blur handler,\r\n     * as well as the number of monitored elements that they contain. We have to treat focus/blur\r\n     * handlers differently from the rest of the events, because the browser won't emit events\r\n     * to the document when focus moves inside of a shadow root.\r\n     */\r\n    private _rootNodeFocusListenerCount;\r\n    /**\r\n     * The specified detection mode, used for attributing the origin of a focus\r\n     * event.\r\n     */\r\n    private readonly _detectionMode;\r\n    /**\r\n     * Event listener for `focus` events on the window.\r\n     * Needs to be an arrow function in order to preserve the context when it gets bound.\r\n     */\r\n    private _windowFocusListener;\r\n    /** Used to reference correct document/window */\r\n    protected _document?: Document;\r\n    /** Subject for stopping our InputModalityDetector subscription. */\r\n    private readonly _stopInputModalityDetector;\r\n    constructor(_ngZone: NgZone, _platform: Platform, _inputModalityDetector: InputModalityDetector, \r\n    /** @breaking-change 11.0.0 make document required */\r\n    document: any | null, options: FocusMonitorOptions | null);\r\n    /**\r\n     * Event listener for `focus` and 'blur' events on the document.\r\n     * Needs to be an arrow function in order to preserve the context when it gets bound.\r\n     */\r\n    private _rootNodeFocusAndBlurListener;\r\n    /**\r\n     * Monitors focus on an element and applies appropriate CSS classes.\r\n     * @param element The element to monitor\r\n     * @param checkChildren Whether to count the element as focused when its children are focused.\r\n     * @returns An observable that emits when the focus state of the element changes.\r\n     *     When the element is blurred, null will be emitted.\r\n     */\r\n    monitor(element: HTMLElement, checkChildren?: boolean): Observable<FocusOrigin>;\r\n    /**\r\n     * Monitors focus on an element and applies appropriate CSS classes.\r\n     * @param element The element to monitor\r\n     * @param checkChildren Whether to count the element as focused when its children are focused.\r\n     * @returns An observable that emits when the focus state of the element changes.\r\n     *     When the element is blurred, null will be emitted.\r\n     */\r\n    monitor(element: ElementRef<HTMLElement>, checkChildren?: boolean): Observable<FocusOrigin>;\r\n    /**\r\n     * Stops monitoring an element and removes all focus classes.\r\n     * @param element The element to stop monitoring.\r\n     */\r\n    stopMonitoring(element: HTMLElement): void;\r\n    /**\r\n     * Stops monitoring an element and removes all focus classes.\r\n     * @param element The element to stop monitoring.\r\n     */\r\n    stopMonitoring(element: ElementRef<HTMLElement>): void;\r\n    /**\r\n     * Focuses the element via the specified focus origin.\r\n     * @param element Element to focus.\r\n     * @param origin Focus origin.\r\n     * @param options Options that can be used to configure the focus behavior.\r\n     */\r\n    focusVia(element: HTMLElement, origin: FocusOrigin, options?: FocusOptions): void;\r\n    /**\r\n     * Focuses the element via the specified focus origin.\r\n     * @param element Element to focus.\r\n     * @param origin Focus origin.\r\n     * @param options Options that can be used to configure the focus behavior.\r\n     */\r\n    focusVia(element: ElementRef<HTMLElement>, origin: FocusOrigin, options?: FocusOptions): void;\r\n    ngOnDestroy(): void;\r\n    /** Access injected document if available or fallback to global document reference */\r\n    private _getDocument;\r\n    /** Use defaultView of injected document if available or fallback to global window reference */\r\n    private _getWindow;\r\n    private _toggleClass;\r\n    private _getFocusOrigin;\r\n    /**\r\n     * Returns whether the focus event should be attributed to touch. Recall that in IMMEDIATE mode, a\r\n     * touch origin isn't immediately reset at the next tick (see _setOrigin). This means that when we\r\n     * handle a focus event following a touch interaction, we need to determine whether (1) the focus\r\n     * event was directly caused by the touch interaction or (2) the focus event was caused by a\r\n     * subsequent programmatic focus call triggered by the touch interaction.\r\n     * @param focusEventTarget The target of the focus event under examination.\r\n     */\r\n    private _shouldBeAttributedToTouch;\r\n    /**\r\n     * Sets the focus classes on the element based on the given focus origin.\r\n     * @param element The element to update the classes on.\r\n     * @param origin The focus origin.\r\n     */\r\n    private _setClasses;\r\n    /**\r\n     * Updates the focus origin. If we're using immediate detection mode, we schedule an async\r\n     * function to clear the origin at the end of a timeout. The duration of the timeout depends on\r\n     * the origin being set.\r\n     * @param origin The origin to set.\r\n     * @param isFromInteraction Whether we are setting the origin from an interaction event.\r\n     */\r\n    private _setOrigin;\r\n    /**\r\n     * Handles focus events on a registered element.\r\n     * @param event The focus event.\r\n     * @param element The monitored element.\r\n     */\r\n    private _onFocus;\r\n    /**\r\n     * Handles blur events on a registered element.\r\n     * @param event The blur event.\r\n     * @param element The monitored element.\r\n     */\r\n    _onBlur(event: FocusEvent, element: HTMLElement): void;\r\n    private _emitOrigin;\r\n    private _registerGlobalListeners;\r\n    private _removeGlobalListeners;\r\n    /** Updates all the state on an element once its focus origin has changed. */\r\n    private _originChanged;\r\n    /**\r\n     * Collects the `MonitoredElementInfo` of a particular element and\r\n     * all of its ancestors that have enabled `checkChildren`.\r\n     * @param element Element from which to start the search.\r\n     */\r\n    private _getClosestElementsInfo;\r\n}\r\n/**\r\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\r\n * programmatically) and adds corresponding classes to the element.\r\n *\r\n * There are two variants of this directive:\r\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\r\n *    focused.\r\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\r\n */\r\nexport declare class CdkMonitorFocus implements AfterViewInit, OnDestroy {\r\n    private _elementRef;\r\n    private _focusMonitor;\r\n    private _monitorSubscription;\r\n    readonly cdkFocusChange: EventEmitter<FocusOrigin>;\r\n    constructor(_elementRef: ElementRef<HTMLElement>, _focusMonitor: FocusMonitor);\r\n    ngAfterViewInit(): void;\r\n    ngOnDestroy(): void;\r\n}\r\n"]}