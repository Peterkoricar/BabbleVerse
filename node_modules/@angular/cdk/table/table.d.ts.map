{"version":3,"file":"table.d.ts","sources":["table.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Directionality } from '@angular/cdk/bidi';\r\nimport { BooleanInput } from '@angular/cdk/coercion';\r\nimport { CollectionViewer, DataSource, _ViewRepeater } from '@angular/cdk/collections';\r\nimport { Platform } from '@angular/cdk/platform';\r\nimport { ViewportRuler } from '@angular/cdk/scrolling';\r\nimport { AfterContentChecked, ChangeDetectorRef, ElementRef, EventEmitter, IterableDiffers, OnDestroy, OnInit, QueryList, TrackByFunction, ViewContainerRef } from '@angular/core';\r\nimport { BehaviorSubject, Observable } from 'rxjs';\r\nimport { CdkColumnDef } from './cell';\r\nimport { _CoalescedStyleScheduler } from './coalesced-style-scheduler';\r\nimport { CdkCellOutletMultiRowContext, CdkCellOutletRowContext, CdkFooterRowDef, CdkHeaderRowDef, CdkNoDataRow, CdkRowDef } from './row';\r\nimport { StickyPositioningListener } from './sticky-position-listener';\r\n/**\r\n * Enables the recycle view repeater strategy, which reduces rendering latency. Not compatible with\r\n * tables that animate rows.\r\n */\r\nexport declare class CdkRecycleRows {\r\n}\r\n/** Interface used to provide an outlet for rows to be inserted into. */\r\nexport interface RowOutlet {\r\n    viewContainer: ViewContainerRef;\r\n}\r\n/**\r\n * Union of the types that can be set as the data source for a `CdkTable`.\r\n * @docs-private\r\n */\r\ndeclare type CdkTableDataSourceInput<T> = readonly T[] | DataSource<T> | Observable<readonly T[]>;\r\n/**\r\n * Provides a handle for the table to grab the view container's ng-container to insert data rows.\r\n * @docs-private\r\n */\r\nexport declare class DataRowOutlet implements RowOutlet {\r\n    viewContainer: ViewContainerRef;\r\n    elementRef: ElementRef;\r\n    constructor(viewContainer: ViewContainerRef, elementRef: ElementRef);\r\n}\r\n/**\r\n * Provides a handle for the table to grab the view container's ng-container to insert the header.\r\n * @docs-private\r\n */\r\nexport declare class HeaderRowOutlet implements RowOutlet {\r\n    viewContainer: ViewContainerRef;\r\n    elementRef: ElementRef;\r\n    constructor(viewContainer: ViewContainerRef, elementRef: ElementRef);\r\n}\r\n/**\r\n * Provides a handle for the table to grab the view container's ng-container to insert the footer.\r\n * @docs-private\r\n */\r\nexport declare class FooterRowOutlet implements RowOutlet {\r\n    viewContainer: ViewContainerRef;\r\n    elementRef: ElementRef;\r\n    constructor(viewContainer: ViewContainerRef, elementRef: ElementRef);\r\n}\r\n/**\r\n * Provides a handle for the table to grab the view\r\n * container's ng-container to insert the no data row.\r\n * @docs-private\r\n */\r\nexport declare class NoDataRowOutlet implements RowOutlet {\r\n    viewContainer: ViewContainerRef;\r\n    elementRef: ElementRef;\r\n    constructor(viewContainer: ViewContainerRef, elementRef: ElementRef);\r\n}\r\n/**\r\n * The table template that can be used by the mat-table. Should not be used outside of the\r\n * material library.\r\n * @docs-private\r\n */\r\nexport declare const CDK_TABLE_TEMPLATE = \"\\n  <ng-content select=\\\"caption\\\"></ng-content>\\n  <ng-content select=\\\"colgroup, col\\\"></ng-content>\\n  <ng-container headerRowOutlet></ng-container>\\n  <ng-container rowOutlet></ng-container>\\n  <ng-container noDataRowOutlet></ng-container>\\n  <ng-container footerRowOutlet></ng-container>\\n\";\r\n/**\r\n * Interface used to conveniently type the possible context interfaces for the render row.\r\n * @docs-private\r\n */\r\nexport interface RowContext<T> extends CdkCellOutletMultiRowContext<T>, CdkCellOutletRowContext<T> {\r\n}\r\n/**\r\n * Set of properties that represents the identity of a single rendered row.\r\n *\r\n * When the table needs to determine the list of rows to render, it will do so by iterating through\r\n * each data object and evaluating its list of row templates to display (when multiTemplateDataRows\r\n * is false, there is only one template per data object). For each pair of data object and row\r\n * template, a `RenderRow` is added to the list of rows to render. If the data object and row\r\n * template pair has already been rendered, the previously used `RenderRow` is added; else a new\r\n * `RenderRow` is * created. Once the list is complete and all data objects have been itereated\r\n * through, a diff is performed to determine the changes that need to be made to the rendered rows.\r\n *\r\n * @docs-private\r\n */\r\nexport interface RenderRow<T> {\r\n    data: T;\r\n    dataIndex: number;\r\n    rowDef: CdkRowDef<T>;\r\n}\r\n/**\r\n * A data table that can render a header row, data rows, and a footer row.\r\n * Uses the dataSource input to determine the data to be rendered. The data can be provided either\r\n * as a data array, an Observable stream that emits the data array to render, or a DataSource with a\r\n * connect function that will return an Observable stream that emits the data array to render.\r\n */\r\nexport declare class CdkTable<T> implements AfterContentChecked, CollectionViewer, OnDestroy, OnInit {\r\n    protected readonly _differs: IterableDiffers;\r\n    protected readonly _changeDetectorRef: ChangeDetectorRef;\r\n    protected readonly _elementRef: ElementRef;\r\n    protected readonly _dir: Directionality;\r\n    private _platform;\r\n    protected readonly _viewRepeater: _ViewRepeater<T, RenderRow<T>, RowContext<T>>;\r\n    protected readonly _coalescedStyleScheduler: _CoalescedStyleScheduler;\r\n    private readonly _viewportRuler;\r\n    /**\r\n     * @deprecated `_stickyPositioningListener` parameter to become required.\r\n     * @breaking-change 13.0.0\r\n     */\r\n    protected readonly _stickyPositioningListener: StickyPositioningListener;\r\n    private _document;\r\n    /** Latest data provided by the data source. */\r\n    protected _data: readonly T[];\r\n    /** Subject that emits when the component has been destroyed. */\r\n    private readonly _onDestroy;\r\n    /** List of the rendered rows as identified by their `RenderRow` object. */\r\n    private _renderRows;\r\n    /** Subscription that listens for the data provided by the data source. */\r\n    private _renderChangeSubscription;\r\n    /**\r\n     * Map of all the user's defined columns (header, data, and footer cell template) identified by\r\n     * name. Collection populated by the column definitions gathered by `ContentChildren` as well as\r\n     * any custom column definitions added to `_customColumnDefs`.\r\n     */\r\n    private _columnDefsByName;\r\n    /**\r\n     * Set of all row definitions that can be used by this table. Populated by the rows gathered by\r\n     * using `ContentChildren` as well as any custom row definitions added to `_customRowDefs`.\r\n     */\r\n    private _rowDefs;\r\n    /**\r\n     * Set of all header row definitions that can be used by this table. Populated by the rows\r\n     * gathered by using `ContentChildren` as well as any custom row definitions added to\r\n     * `_customHeaderRowDefs`.\r\n     */\r\n    private _headerRowDefs;\r\n    /**\r\n     * Set of all row definitions that can be used by this table. Populated by the rows gathered by\r\n     * using `ContentChildren` as well as any custom row definitions added to\r\n     * `_customFooterRowDefs`.\r\n     */\r\n    private _footerRowDefs;\r\n    /** Differ used to find the changes in the data provided by the data source. */\r\n    private _dataDiffer;\r\n    /** Stores the row definition that does not have a when predicate. */\r\n    private _defaultRowDef;\r\n    /**\r\n     * Column definitions that were defined outside of the direct content children of the table.\r\n     * These will be defined when, e.g., creating a wrapper around the cdkTable that has\r\n     * column definitions as *its* content child.\r\n     */\r\n    private _customColumnDefs;\r\n    /**\r\n     * Data row definitions that were defined outside of the direct content children of the table.\r\n     * These will be defined when, e.g., creating a wrapper around the cdkTable that has\r\n     * built-in data rows as *its* content child.\r\n     */\r\n    private _customRowDefs;\r\n    /**\r\n     * Header row definitions that were defined outside of the direct content children of the table.\r\n     * These will be defined when, e.g., creating a wrapper around the cdkTable that has\r\n     * built-in header rows as *its* content child.\r\n     */\r\n    private _customHeaderRowDefs;\r\n    /**\r\n     * Footer row definitions that were defined outside of the direct content children of the table.\r\n     * These will be defined when, e.g., creating a wrapper around the cdkTable that has a\r\n     * built-in footer row as *its* content child.\r\n     */\r\n    private _customFooterRowDefs;\r\n    /** No data row that was defined outside of the direct content children of the table. */\r\n    private _customNoDataRow;\r\n    /**\r\n     * Whether the header row definition has been changed. Triggers an update to the header row after\r\n     * content is checked. Initialized as true so that the table renders the initial set of rows.\r\n     */\r\n    private _headerRowDefChanged;\r\n    /**\r\n     * Whether the footer row definition has been changed. Triggers an update to the footer row after\r\n     * content is checked. Initialized as true so that the table renders the initial set of rows.\r\n     */\r\n    private _footerRowDefChanged;\r\n    /**\r\n     * Whether the sticky column styles need to be updated. Set to `true` when the visible columns\r\n     * change.\r\n     */\r\n    private _stickyColumnStylesNeedReset;\r\n    /**\r\n     * Whether the sticky styler should recalculate cell widths when applying sticky styles. If\r\n     * `false`, cached values will be used instead. This is only applicable to tables with\r\n     * {@link fixedLayout} enabled. For other tables, cell widths will always be recalculated.\r\n     */\r\n    private _forceRecalculateCellWidths;\r\n    /**\r\n     * Cache of the latest rendered `RenderRow` objects as a map for easy retrieval when constructing\r\n     * a new list of `RenderRow` objects for rendering rows. Since the new list is constructed with\r\n     * the cached `RenderRow` objects when possible, the row identity is preserved when the data\r\n     * and row template matches, which allows the `IterableDiffer` to check rows by reference\r\n     * and understand which rows are added/moved/removed.\r\n     *\r\n     * Implemented as a map of maps where the first key is the `data: T` object and the second is the\r\n     * `CdkRowDef<T>` object. With the two keys, the cache points to a `RenderRow<T>` object that\r\n     * contains an array of created pairs. The array is necessary to handle cases where the data\r\n     * array contains multiple duplicate data objects and each instantiated `RenderRow` must be\r\n     * stored.\r\n     */\r\n    private _cachedRenderRowsMap;\r\n    /** Whether the table is applied to a native `<table>`. */\r\n    protected _isNativeHtmlTable: boolean;\r\n    /**\r\n     * Utility class that is responsible for applying the appropriate sticky positioning styles to\r\n     * the table's rows and cells.\r\n     */\r\n    private _stickyStyler;\r\n    /**\r\n     * CSS class added to any row or cell that has sticky positioning applied. May be overriden by\r\n     * table subclasses.\r\n     */\r\n    protected stickyCssClass: string;\r\n    /**\r\n     * Whether to manually add positon: sticky to all sticky cell elements. Not needed if\r\n     * the position is set in a selector associated with the value of stickyCssClass. May be\r\n     * overridden by table subclasses\r\n     */\r\n    protected needsPositionStickyOnElement: boolean;\r\n    /** Whether the no data row is currently showing anything. */\r\n    private _isShowingNoDataRow;\r\n    /**\r\n     * Tracking function that will be used to check the differences in data changes. Used similarly\r\n     * to `ngFor` `trackBy` function. Optimize row operations by identifying a row based on its data\r\n     * relative to the function to know if a row should be added/removed/moved.\r\n     * Accepts a function that takes two parameters, `index` and `item`.\r\n     */\r\n    get trackBy(): TrackByFunction<T>;\r\n    set trackBy(fn: TrackByFunction<T>);\r\n    private _trackByFn;\r\n    /**\r\n     * The table's source of data, which can be provided in three ways (in order of complexity):\r\n     *   - Simple data array (each object represents one table row)\r\n     *   - Stream that emits a data array each time the array changes\r\n     *   - `DataSource` object that implements the connect/disconnect interface.\r\n     *\r\n     * If a data array is provided, the table must be notified when the array's objects are\r\n     * added, removed, or moved. This can be done by calling the `renderRows()` function which will\r\n     * render the diff since the last table render. If the data array reference is changed, the table\r\n     * will automatically trigger an update to the rows.\r\n     *\r\n     * When providing an Observable stream, the table will trigger an update automatically when the\r\n     * stream emits a new array of data.\r\n     *\r\n     * Finally, when providing a `DataSource` object, the table will use the Observable stream\r\n     * provided by the connect function and trigger updates when that stream emits new data array\r\n     * values. During the table's ngOnDestroy or when the data source is removed from the table, the\r\n     * table will call the DataSource's `disconnect` function (may be useful for cleaning up any\r\n     * subscriptions registered during the connect process).\r\n     */\r\n    get dataSource(): CdkTableDataSourceInput<T>;\r\n    set dataSource(dataSource: CdkTableDataSourceInput<T>);\r\n    private _dataSource;\r\n    /**\r\n     * Whether to allow multiple rows per data object by evaluating which rows evaluate their 'when'\r\n     * predicate to true. If `multiTemplateDataRows` is false, which is the default value, then each\r\n     * dataobject will render the first row that evaluates its when predicate to true, in the order\r\n     * defined in the table, or otherwise the default row which does not have a when predicate.\r\n     */\r\n    get multiTemplateDataRows(): boolean;\r\n    set multiTemplateDataRows(v: boolean);\r\n    _multiTemplateDataRows: boolean;\r\n    /**\r\n     * Whether to use a fixed table layout. Enabling this option will enforce consistent column widths\r\n     * and optimize rendering sticky styles for native tables. No-op for flex tables.\r\n     */\r\n    get fixedLayout(): boolean;\r\n    set fixedLayout(v: boolean);\r\n    private _fixedLayout;\r\n    /**\r\n     * Emits when the table completes rendering a set of data rows based on the latest data from the\r\n     * data source, even if the set of rows is empty.\r\n     */\r\n    readonly contentChanged: EventEmitter<void>;\r\n    /**\r\n     * Stream containing the latest information on what rows are being displayed on screen.\r\n     * Can be used by the data source to as a heuristic of what data should be provided.\r\n     *\r\n     * @docs-private\r\n     */\r\n    readonly viewChange: BehaviorSubject<{\r\n        start: number;\r\n        end: number;\r\n    }>;\r\n    _rowOutlet: DataRowOutlet;\r\n    _headerRowOutlet: HeaderRowOutlet;\r\n    _footerRowOutlet: FooterRowOutlet;\r\n    _noDataRowOutlet: NoDataRowOutlet;\r\n    /**\r\n     * The column definitions provided by the user that contain what the header, data, and footer\r\n     * cells should render for each column.\r\n     */\r\n    _contentColumnDefs: QueryList<CdkColumnDef>;\r\n    /** Set of data row definitions that were provided to the table as content children. */\r\n    _contentRowDefs: QueryList<CdkRowDef<T>>;\r\n    /** Set of header row definitions that were provided to the table as content children. */\r\n    _contentHeaderRowDefs: QueryList<CdkHeaderRowDef>;\r\n    /** Set of footer row definitions that were provided to the table as content children. */\r\n    _contentFooterRowDefs: QueryList<CdkFooterRowDef>;\r\n    /** Row definition that will only be rendered if there's no data in the table. */\r\n    _noDataRow: CdkNoDataRow;\r\n    constructor(_differs: IterableDiffers, _changeDetectorRef: ChangeDetectorRef, _elementRef: ElementRef, role: string, _dir: Directionality, _document: any, _platform: Platform, _viewRepeater: _ViewRepeater<T, RenderRow<T>, RowContext<T>>, _coalescedStyleScheduler: _CoalescedStyleScheduler, _viewportRuler: ViewportRuler, \r\n    /**\r\n     * @deprecated `_stickyPositioningListener` parameter to become required.\r\n     * @breaking-change 13.0.0\r\n     */\r\n    _stickyPositioningListener: StickyPositioningListener);\r\n    ngOnInit(): void;\r\n    ngAfterContentChecked(): void;\r\n    ngOnDestroy(): void;\r\n    /**\r\n     * Renders rows based on the table's latest set of data, which was either provided directly as an\r\n     * input or retrieved through an Observable stream (directly or from a DataSource).\r\n     * Checks for differences in the data since the last diff to perform only the necessary\r\n     * changes (add/remove/move rows).\r\n     *\r\n     * If the table's data source is a DataSource or Observable, this will be invoked automatically\r\n     * each time the provided Observable stream emits a new data array. Otherwise if your data is\r\n     * an array, this function will need to be called to render any changes.\r\n     */\r\n    renderRows(): void;\r\n    /** Adds a column definition that was not included as part of the content children. */\r\n    addColumnDef(columnDef: CdkColumnDef): void;\r\n    /** Removes a column definition that was not included as part of the content children. */\r\n    removeColumnDef(columnDef: CdkColumnDef): void;\r\n    /** Adds a row definition that was not included as part of the content children. */\r\n    addRowDef(rowDef: CdkRowDef<T>): void;\r\n    /** Removes a row definition that was not included as part of the content children. */\r\n    removeRowDef(rowDef: CdkRowDef<T>): void;\r\n    /** Adds a header row definition that was not included as part of the content children. */\r\n    addHeaderRowDef(headerRowDef: CdkHeaderRowDef): void;\r\n    /** Removes a header row definition that was not included as part of the content children. */\r\n    removeHeaderRowDef(headerRowDef: CdkHeaderRowDef): void;\r\n    /** Adds a footer row definition that was not included as part of the content children. */\r\n    addFooterRowDef(footerRowDef: CdkFooterRowDef): void;\r\n    /** Removes a footer row definition that was not included as part of the content children. */\r\n    removeFooterRowDef(footerRowDef: CdkFooterRowDef): void;\r\n    /** Sets a no data row definition that was not included as a part of the content children. */\r\n    setNoDataRow(noDataRow: CdkNoDataRow | null): void;\r\n    /**\r\n     * Updates the header sticky styles. First resets all applied styles with respect to the cells\r\n     * sticking to the top. Then, evaluating which cells need to be stuck to the top. This is\r\n     * automatically called when the header row changes its displayed set of columns, or if its\r\n     * sticky input changes. May be called manually for cases where the cell content changes outside\r\n     * of these events.\r\n     */\r\n    updateStickyHeaderRowStyles(): void;\r\n    /**\r\n     * Updates the footer sticky styles. First resets all applied styles with respect to the cells\r\n     * sticking to the bottom. Then, evaluating which cells need to be stuck to the bottom. This is\r\n     * automatically called when the footer row changes its displayed set of columns, or if its\r\n     * sticky input changes. May be called manually for cases where the cell content changes outside\r\n     * of these events.\r\n     */\r\n    updateStickyFooterRowStyles(): void;\r\n    /**\r\n     * Updates the column sticky styles. First resets all applied styles with respect to the cells\r\n     * sticking to the left and right. Then sticky styles are added for the left and right according\r\n     * to the column definitions for each cell in each row. This is automatically called when\r\n     * the data source provides a new set of data or when a column definition changes its sticky\r\n     * input. May be called manually for cases where the cell content changes outside of these events.\r\n     */\r\n    updateStickyColumnStyles(): void;\r\n    /**\r\n     * Get the list of RenderRow objects to render according to the current list of data and defined\r\n     * row definitions. If the previous list already contained a particular pair, it should be reused\r\n     * so that the differ equates their references.\r\n     */\r\n    private _getAllRenderRows;\r\n    /**\r\n     * Gets a list of `RenderRow<T>` for the provided data object and any `CdkRowDef` objects that\r\n     * should be rendered for this data. Reuses the cached RenderRow objects if they match the same\r\n     * `(T, CdkRowDef)` pair.\r\n     */\r\n    private _getRenderRowsForData;\r\n    /** Update the map containing the content's column definitions. */\r\n    private _cacheColumnDefs;\r\n    /** Update the list of all available row definitions that can be used. */\r\n    private _cacheRowDefs;\r\n    /**\r\n     * Check if the header, data, or footer rows have changed what columns they want to display or\r\n     * whether the sticky states have changed for the header or footer. If there is a diff, then\r\n     * re-render that section.\r\n     */\r\n    private _renderUpdatedColumns;\r\n    /**\r\n     * Switch to the provided data source by resetting the data and unsubscribing from the current\r\n     * render change subscription if one exists. If the data source is null, interpret this by\r\n     * clearing the row outlet. Otherwise start listening for new data.\r\n     */\r\n    private _switchDataSource;\r\n    /** Set up a subscription for the data provided by the data source. */\r\n    private _observeRenderChanges;\r\n    /**\r\n     * Clears any existing content in the header row outlet and creates a new embedded view\r\n     * in the outlet using the header row definition.\r\n     */\r\n    private _forceRenderHeaderRows;\r\n    /**\r\n     * Clears any existing content in the footer row outlet and creates a new embedded view\r\n     * in the outlet using the footer row definition.\r\n     */\r\n    private _forceRenderFooterRows;\r\n    /** Adds the sticky column styles for the rows according to the columns' stick states. */\r\n    private _addStickyColumnStyles;\r\n    /** Gets the list of rows that have been rendered in the row outlet. */\r\n    _getRenderedRows(rowOutlet: RowOutlet): HTMLElement[];\r\n    /**\r\n     * Get the matching row definitions that should be used for this row data. If there is only\r\n     * one row definition, it is returned. Otherwise, find the row definitions that has a when\r\n     * predicate that returns true with the data. If none return true, return the default row\r\n     * definition.\r\n     */\r\n    _getRowDefs(data: T, dataIndex: number): CdkRowDef<T>[];\r\n    private _getEmbeddedViewArgs;\r\n    /**\r\n     * Creates a new row template in the outlet and fills it with the set of cell templates.\r\n     * Optionally takes a context to provide to the row and cells, as well as an optional index\r\n     * of where to place the new row template in the outlet.\r\n     */\r\n    private _renderRow;\r\n    private _renderCellTemplateForItem;\r\n    /**\r\n     * Updates the index-related context for each row to reflect any changes in the index of the rows,\r\n     * e.g. first/last/even/odd.\r\n     */\r\n    private _updateRowIndexContext;\r\n    /** Gets the column definitions for the provided row def. */\r\n    private _getCellTemplates;\r\n    /** Adds native table sections (e.g. tbody) and moves the row outlets into them. */\r\n    private _applyNativeTableSections;\r\n    /**\r\n     * Forces a re-render of the data rows. Should be called in cases where there has been an input\r\n     * change that affects the evaluation of which rows should be rendered, e.g. toggling\r\n     * `multiTemplateDataRows` or adding/removing row definitions.\r\n     */\r\n    private _forceRenderDataRows;\r\n    /**\r\n     * Checks if there has been a change in sticky states since last check and applies the correct\r\n     * sticky styles. Since checking resets the \"dirty\" state, this should only be performed once\r\n     * during a change detection and after the inputs are settled (after content check).\r\n     */\r\n    private _checkStickyStates;\r\n    /**\r\n     * Creates the sticky styler that will be used for sticky rows and columns. Listens\r\n     * for directionality changes and provides the latest direction to the styler. Re-applies column\r\n     * stickiness when directionality changes.\r\n     */\r\n    private _setupStickyStyler;\r\n    /** Filters definitions that belong to this table from a QueryList. */\r\n    private _getOwnDefs;\r\n    /** Creates or removes the no data row, depending on whether any data is being shown. */\r\n    private _updateNoDataRow;\r\n    static ngAcceptInputType_multiTemplateDataRows: BooleanInput;\r\n    static ngAcceptInputType_fixedLayout: BooleanInput;\r\n}\r\nexport {};\r\n"]}